/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;



terminal  SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO, RESTO;
terminal  IDENTIFICADOR, AND, OR, XOR, SHIFT_LEFT, SHIFT_RIGHT, AND_NOT;
terminal  ATRIBUICAO_SOMA, ATRIBUICAO_SUB, ATRIBUICAO_MULT, ATRIBUICAO_DIV, ATRIBUICAO_RESTO;
terminal  ATRIBUICAO_AND, ATRIBUICAO_OR, ATRIBUICAO_XOR, ATRIBUICAO_SL, ATRIBUICAO_SR, ATRICUICAO_AND_NOT;
terminal  LAND, LOR, ARROW, INC, DEC;
terminal  IGUAL, MAIOR_QUE, MENOR_QUE, ATRIBUICAO, NOT;
terminal  DIFERENTE, MENOR_IGUAL, MAIOR_IGUAL, DEFINE, ELLIPSIS;
terminal  PARENESQ, PARENDIR, CHAVEESQ, CHAVEDIR, COLCHESQ, COLCHDIR, VIRGULA, PONTO, DOISPONTOS, PONTOVIRGULA;
terminal  BREAK, CASE, CHAN, CONST, CONTINUE;
terminal  DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR; 
terminal  FUNC, GO, GOTO, IF, IMPORT;
terminal  INTERFACE, MAP, PACKAGE, RANGE, RETURN;
terminal  SELECT, STRUCT, SWITCH, TYPE, VAR;
terminal  TIPOBOOL, UNTYPEDNIL, UNTYPEDSTRING, TIPOSTRING, TIPOBOOL, TIPOINT, TIPOFLOAT32,TIPOFLOAT64;
terminal  INICIOCOMENT, FINALCOMENT, EOF;
terminal  BRANCO,  BOOL, COMPLEX, INTEIRO, FLOAT, ID;

non terminal   program;
non terminal   int_lit , float_lit, string_lit;
non terminal   identifier;
non terminal   rel_op, add_op , mul_op, binary_op, unary_oper;
non terminal   expression, UnaryExpr;
non terminal   Operand, Literal , BasicLit, CompositeLit ,FunctionLit;



/* The grammar rules */

identifier ::= ID ;

Expression ::= UnaryExpr | Expression binary_op Expression;
UnaryExpr  ::= PrimaryExpr | unary_op UnaryExpr

binary_op  ::= LOR | LAND | rel_op | add_op | mul_op;
rel_op     ::= IGUAL | DIFERENTE | MENOR_QUE | MENOR_IGUAL | MAIOR_QUE | MAIOR_IGUAL;
add_op     ::= SOMA | SUBTRACAO | OR | XOR ;
mul_op     ::= MULTIPLICACAO | DIVISAO | RESTO | SHIFT_LEFT | SHIFT_RIGHT | AND_NOT | AND ;

unary_op   ::= SOMA | SUBTRACAO | NOT | XOR | MULTIPLICACAO | AND | ARROW; 


FunctionType   ::= "func" Signature ;
Signature      = Parameters [ Result ] ;
Result         = Parameters | Type ;
Parameters     = "(" [ ParameterList [ "," ] ] ")" ;
ParameterList  = ParameterDecl { "," ParameterDecl } ;
ParameterDecl  = [ IdentifierList ] [ "..." ] Type ;

Operand     = Literal | OperandName | "(" Expression ")" ;
Literal     = BasicLit | CompositeLit | FunctionLit ;
BasicLit    ::= ID | BOOL | FLOAT | INTEIRO;
OperandName ::= identifier | QualifiedIdent;

QualifiedIdent ::= PackageName PONTO identifier ;

PackageClause  ::= PACKAGE PackageName ;
PackageName    ::= identifier ;

ImportDecl       ::= IMPORT PARENESQ ImportSpec | PARENESQ COLCHESQ ImportSpec PONTOVIRGULA COLCHDIR  PARENDIR PARENDIR;
ImportSpec       ::= CHAVEESQ PONTO | PackageName CHAVEDIR ImportPath ;
ImportPath       ::= ID ;


PrimaryExpr ::=  Operand |
                 Conversion |
				 MethodExpr |
				 PrimaryExpr Selector |
				 PrimaryExpr Index |
				 PrimaryExpr Slice |
				 PrimaryExpr TypeAssertion |
				 PrimaryExpr Arguments .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" .
TypeAssertion  = "." "(" Type ")" .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .


FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .



